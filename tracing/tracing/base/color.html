<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/tracing/base/base.html">
<script>
'use strict';

tr.exportTo('tr.b', function() {

  function Color(opt_r, opt_g, opt_b, opt_a) {
    this.r = Math.floor(opt_r) || 0;
    this.g = Math.floor(opt_g) || 0;
    this.b = Math.floor(opt_b) || 0;
    this.a = opt_a;
  }

  Color.fromString = function(str) {
    var tmp;
    var values;
    if (str.substr(0, 4) == 'rgb(') {
      tmp = str.substr(4, str.length - 5);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 3)
        throw new Error('Malformatted rgb-expression');
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]));
    } else if (str.substr(0, 5) == 'rgba(') {
      tmp = str.substr(5, str.length - 6);
      values = tmp.split(',').map(function(v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 4)
        throw new Error('Malformatted rgb-expression');
      return new Color(
          parseInt(values[0]),
          parseInt(values[1]),
          parseInt(values[2]),
          parseFloat(values[3]));
    } else if (str[0] == '#' && str.length == 7) {
      return new Color(
          parseInt(str.substr(1, 2), 16),
          parseInt(str.substr(3, 2), 16),
          parseInt(str.substr(5, 2), 16));
    } else {
      throw new Error('Unrecognized string format.');
    }
  };

  Color.lerp = function(a, b, percent) {
    if (a.a !== undefined && b.a !== undefined)
      return Color.lerpRGBA(a, b, percent);
    return Color.lerpRGB(a, b, percent);
  };

  Color.lerpRGB = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b);
  };

  Color.lerpRGBA = function(a, b, percent) {
    return new Color(
        ((b.r - a.r) * percent) + a.r,
        ((b.g - a.g) * percent) + a.g,
        ((b.b - a.b) * percent) + a.b,
        ((b.a - a.a) * percent) + a.a);
  };

  Color.fromDict = function(dict) {
    return new Color(dict.r, dict.g, dict.b, dict.a);
  };

  /**
   * Converts an HSV triplet with alpha to an RGB color.
   * |h| Hue value in [0, 360].
   * |s| Saturation value in [0, 1].
   * |v| Value (brightness) in [0, 255].
   * |a| Alpha in [0, 1]
   */
  Color.fromHSV = function(h, s, v, a) {
    var red = 0;
    var green = 0;
    var blue = 0;
    if (s === 0) {
      red = v;
      green = v;
      blue = v;
    } else {
      var sextant = Math.floor(h / 60);
      var remainder = (h / 60) - sextant;
      var val1 = v * (1 - s);
      var val2 = v * (1 - (s * remainder));
      var val3 = v * (1 - (s * (1 - remainder)));
      switch (sextant) {
        case 1:
          red = val2;
          green = v;
          blue = val1;
          break;
        case 2:
          red = val1;
          green = v;
          blue = val3;
          break;
        case 3:
          red = val1;
          green = val2;
          blue = v;
          break;
        case 4:
          red = val3;
          green = val1;
          blue = v;
          break;
        case 5:
          red = v;
          green = val1;
          blue = val2;
          break;
        case 6:
        case 0:
          red = v;
          green = val3;
          blue = val1;
          break;
      }
    }

    return new Color(Math.floor(red), Math.floor(green), Math.floor(blue), a);
  }

  Color.prototype = {
    clone: function() {
      var c = new Color();
      c.r = this.r;
      c.g = this.g;
      c.b = this.b;
      c.a = this.a;
      return c;
    },

    blendOver: function(bgColor) {
      var oneMinusThisAlpha = 1 - this.a;
      var outA = this.a + bgColor.a * oneMinusThisAlpha;
      var bgBlend = (bgColor.a * oneMinusThisAlpha) / bgColor.a;
      return new Color(
          this.r * this.a + bgColor.r * bgBlend,
          this.g * this.a + bgColor.g * bgBlend,
          this.b * this.a + bgColor.b * bgBlend,
          outA);
    },

    brighten: function(opt_k) {
      var k;
      k = opt_k || 0.45;

      return new Color(
          Math.min(255, this.r + Math.floor(this.r * k)),
          Math.min(255, this.g + Math.floor(this.g * k)),
          Math.min(255, this.b + Math.floor(this.b * k)),
          this.a);
    },

    /*
     * Legacy brightening function used by TimelineTracks. Avoid using.
     *
     * Coloring in trace viewer is one of the oldest parts of the code, and
     * was very organically built. At the time, we didn't want to code up
     * a proper HSV implementation, so to brighten colors, we scale them up
     * with a simple multiply. But, that sometimes made them too bright,
     * so then we sometimes dim them, when they're already bright.
     *
     * People are used to the coloring scheme, so today we keep this function
     * around for consistency. Hopefully, someday we can ditch this for
     * a more consisistent, HSV-based approach.
     *
     * This isn't particularly clever, but it gets the job done. And clever
     * like the most polite euphamism to use, considering reality. :)
     */
    brightenCleverly: function() {
      var k;
      if (this.r >= 240 && this.g >= 240 && this.b >= 240)
        k = 0.80;
      else
        k = 1.45;
      return new Color(
          Math.min(255, Math.floor(this.r * k)),
          Math.min(255, Math.floor(this.g * k)),
          Math.min(255, Math.floor(this.b * k)),
          this.a);
    },

    darken: function(opt_k) {
      var k;
      if (opt_k !== undefined)
        k = opt_k;
      else
        k = 0.45;

      return new Color(
          Math.min(255, this.r - Math.floor(this.r * k)),
          Math.min(255, this.g - Math.floor(this.g * k)),
          Math.min(255, this.b - Math.floor(this.b * k)),
          this.a);
    },

    desaturate: function() {
      var value = Math.min((this.r + this.g + this.b) / 3, 255);
      return new Color(value, value, value, this.a);
    },

    withAlpha: function(a) {
      return new Color(this.r, this.g, this.b, a);
    },

    toString: function() {
      if (this.a !== undefined) {
        return 'rgba(' +
            this.r + ',' + this.g + ',' +
            this.b + ',' + this.a + ')';
      }
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    },

    /**
     * Returns a dict {h, s, v, a} with:
     * |h| Hue value in [0, 360].
     * |s| Saturation value in [0, 1].
     * |v| Value (brightness) in [0, 255].
     * |a| Alpha in [0, 1]
     */
    toHSV: function() {
      var max = Math.max(Math.max(this.r, this.g), this.b);
      var min = Math.min(Math.min(this.r, this.g), this.b);
      var hue;
      var saturation;
      var value = max;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = (max - min);
        saturation = delta / max;

        if (this.r === max) {
          hue = (this.g - this.b) / delta;
        } else if (this.g === max) {
          hue = 2 + ((this.b - this.r) / delta);
        } else {
          hue = 4 + ((this.r - this.g) / delta);
        }
        hue *= 60;
        if (hue < 0)
          hue += 360;
        if (hue > 360)
          hue -= 360;
      }

      return {h: hue, s: saturation, v: value, a: this.a};
    },

    toStringWithAlphaOverride: function(alpha) {
      return 'rgba(' +
          this.r + ',' + this.g + ',' +
          this.b + ',' + alpha + ')';
    }
  };

  return {
    Color: Color
  };
});
</script>
