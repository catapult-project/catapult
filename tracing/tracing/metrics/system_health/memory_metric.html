<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/base/fixed_color_scheme.html">
<link rel="import" href="/tracing/base/iteration_helpers.html">
<link rel="import" href="/tracing/base/multi_dimensional_view.html">
<link rel="import" href="/tracing/base/range.html">
<link rel="import" href="/tracing/base/unit.html">
<link rel="import" href="/tracing/metrics/metric_registry.html">
<link rel="import" href="/tracing/model/container_memory_dump.html">
<link rel="import" href="/tracing/model/helpers/chrome_model_helper.html">
<link rel="import" href="/tracing/model/memory_allocator_dump.html">
<link rel="import" href="/tracing/value/diagnostics/breakdown.html">
<link rel="import" href="/tracing/value/histogram.html">

<script>
'use strict';

tr.exportTo('tr.metrics.sh', function() {
  var BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
  var LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
  var DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;
  var sizeInBytes_smallerIsBetter =
      tr.b.Unit.byName.sizeInBytes_smallerIsBetter;
  var count_smallerIsBetter = tr.b.Unit.byName.count_smallerIsBetter;
  var DISPLAYED_SIZE_NUMERIC_NAME =
      tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;

  var LEVEL_OF_DETAIL_NAMES = new Map();
  LEVEL_OF_DETAIL_NAMES.set(BACKGROUND, 'background');
  LEVEL_OF_DETAIL_NAMES.set(LIGHT, 'light');
  LEVEL_OF_DETAIL_NAMES.set(DETAILED, 'detailed');

  // Some detailed dumps contain heap profiler information.
  var HEAP_PROFILER_DETAIL_NAME = 'heap_profiler';

  var BOUNDARIES_FOR_UNIT_MAP = new WeakMap();
  // For unitless numerics (process counts), we use 20 linearly scaled bins
  // from 0 to 20.
  BOUNDARIES_FOR_UNIT_MAP.set(count_smallerIsBetter,
      tr.v.HistogramBinBoundaries.createLinear(0, 20, 20));
  // For size numerics (subsystem and vm stats), we use 1 bin from 0 B to
  // 1 KiB and 4*24 exponentially scaled bins from 1 KiB to 16 GiB (=2^24 KiB).
  BOUNDARIES_FOR_UNIT_MAP.set(sizeInBytes_smallerIsBetter,
      new tr.v.HistogramBinBoundaries(0)
          .addBinBoundary(1024 /* 1 KiB */)
          .addExponentialBins(16 * 1024 * 1024 * 1024 /* 16 GiB */, 4 * 24));

  var BROWSER_PROCESS_NAME = 'browser_process';
  var RENDERER_PROCESSES_NAME = 'renderer_processes'; // Intentionally plural.
  var ALL_PROCESSES_NAME = 'all_processes';
  var GPU_PROCESS_NAME = 'gpu_process';
  var PPAPI_PROCESS_NAME = 'ppapi_process';
  var UNKNOWN_PROCESSES_NAME = 'unknown_processes';
  // When adding a new process id update KNOWN_PROCESS_NAMES.

  var KNOWN_PROCESS_NAMES = [
    BROWSER_PROCESS_NAME,
    RENDERER_PROCESSES_NAME,
    ALL_PROCESSES_NAME,
    GPU_PROCESS_NAME,
    PPAPI_PROCESS_NAME,
    UNKNOWN_PROCESSES_NAME
  ];

  var PROCESS_COLOR_SCHEME_NAME = 'ChromeProcessNames';
  var PROCESS_COLOR_SCHEME =
      tr.b.FixedColorScheme.fromNames(KNOWN_PROCESS_NAMES);
  tr.b.FixedColorSchemeRegistry.register(() => PROCESS_COLOR_SCHEME, {
    'name': PROCESS_COLOR_SCHEME_NAME,
  });

  function memoryMetric(values, model, opt_options) {
    var rangeOfInterest = opt_options ? opt_options.rangeOfInterest : undefined;
    var browserNameToGlobalDumps =
        splitGlobalDumpsByBrowserName(model, rangeOfInterest);
    addGeneralMemoryDumpValues(browserNameToGlobalDumps, values);
    addDetailedMemoryDumpValues(browserNameToGlobalDumps, values);
    addMemoryDumpCountValues(browserNameToGlobalDumps, values);
  }

  /**
   * Splits the global memory dumps in |model| by browser name.
   *
   * @param {!tr.Model} model The trace model from which the global dumps
   *     should be extracted.
   * @param {!tr.b.Range=} opt_rangeOfInterest If proided, global memory dumps
   *     that do not inclusively intersect the range will be skipped.
   * @return {!Map<string, !Array<!tr.model.GlobalMemoryDump>} A map from
   *     browser names to the associated global memory dumps.
   */
  function splitGlobalDumpsByBrowserName(model, opt_rangeOfInterest) {
    var chromeModelHelper =
        model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    var browserNameToGlobalDumps = new Map();
    var globalDumpToBrowserHelper = new WeakMap();

    // 1. For each browser process in the model, add its global memory dumps to
    // |browserNameToGlobalDumps|. |chromeModelHelper| can be undefined if
    // it fails to find any browser, renderer or GPU process (see
    // tr.model.helpers.ChromeModelHelper.supportsModel).
    if (chromeModelHelper) {
      chromeModelHelper.browserHelpers.forEach(function(helper) {
        // Retrieve the associated global memory dumps and check that they
        // haven't been classified as belonging to another browser process.
        var globalDumps = skipDumpsThatDoNotIntersectRange(
            helper.process.memoryDumps.map(d => d.globalMemoryDump),
            opt_rangeOfInterest);
        globalDumps.forEach(function(globalDump) {
          var existingHelper = globalDumpToBrowserHelper.get(globalDump);
          if (existingHelper !== undefined) {
            throw new Error('Memory dump ID clash across multiple browsers ' +
                'with PIDs: ' + existingHelper.pid + ' and ' + helper.pid);
          }
          globalDumpToBrowserHelper.set(globalDump, helper);
        });

        makeKeyUniqueAndSet(browserNameToGlobalDumps,
            canonicalizeName(helper.browserName), globalDumps);
      });
    }

    // 2. If any global memory dump does not have any associated browser
    // process for some reason, associate it with an 'unknown_browser' browser
    // so that we don't lose the data.
    var unclassifiedGlobalDumps = skipDumpsThatDoNotIntersectRange(
        model.globalMemoryDumps.filter(g => !globalDumpToBrowserHelper.has(g)),
        opt_rangeOfInterest);
    if (unclassifiedGlobalDumps.length > 0) {
      makeKeyUniqueAndSet(
          browserNameToGlobalDumps, 'unknown_browser', unclassifiedGlobalDumps);
    }

    return browserNameToGlobalDumps;
  }

  function skipDumpsThatDoNotIntersectRange(dumps, opt_range) {
    if (!opt_range)
      return dumps;
    return dumps.filter(d => opt_range.intersectsExplicitRangeInclusive(
        d.start, d.end));
  }

  function canonicalizeName(name) {
    return name.toLowerCase().replace(' ', '_');
  }

  var USER_FRIENDLY_BROWSER_NAMES = {
    'chrome': 'Chrome',
    'webview': 'WebView',
    'unknown_browser': 'an unknown browser'
  };

  /**
   * Convert a canonical browser name used in value names to a user-friendly
   * name used in value descriptions.
   *
   * Examples:
   *
   *   CANONICAL BROWSER NAME -> USER-FRIENDLY NAME
   *   chrome                 -> Chrome
   *   unknown_browser        -> an unknown browser
   *   webview2               -> WebView(2)
   *   unexpected             -> 'unexpected' browser
   */
  function convertBrowserNameToUserFriendlyName(browserName) {
    for (var baseName in USER_FRIENDLY_BROWSER_NAMES) {
      if (!browserName.startsWith(baseName))
        continue;
      var userFriendlyBaseName = USER_FRIENDLY_BROWSER_NAMES[baseName];
      var suffix = browserName.substring(baseName.length);
      if (suffix.length === 0)
        return userFriendlyBaseName;
      else if (/^\d+$/.test(suffix))
        return userFriendlyBaseName + '(' + suffix + ')';
    }
    return '\'' + browserName + '\' browser';
  }

  function canonicalizeProcessName(rawProcessName) {
    if (!rawProcessName)
      return UNKNOWN_PROCESSES_NAME;
    var baseCanonicalName = canonicalizeName(rawProcessName);
    switch (baseCanonicalName) {
      case 'renderer':
        return RENDERER_PROCESSES_NAME;
      case 'browser':
        return BROWSER_PROCESS_NAME;
      default:
        if (KNOWN_PROCESS_NAMES.indexOf(baseCanonicalName) === -1) {
          // In the very rare case where a new process type has been added
          // and this file has not yet been updated add it to the list of known
          // process ids so we can give it a consistent color in the UI.
          console.warn('Unknown process id "' + baseCanonicalName + '".' +
            ' Please add it to |KNOWN_PROCESS_NAMES| in memory_metric.html.');
          KNOWN_PROCESS_NAMES.push(baseCanonicalName);
          PROCESS_COLOR_SCHEME =
            tr.b.FixedColorScheme.fromNames(KNOWN_PROCESS_NAMES);
        }
        return baseCanonicalName;
    }
  }

  /**
   * Convert a canonical process name used in value names to a user-friendly
   * name used in value descriptions.
   */
  function convertProcessNameToUserFriendlyName(processName,
      opt_requirePlural) {
    switch (processName) {
      case BROWSER_PROCESS_NAME:
        return opt_requirePlural ? 'browser processes' : 'the browser process';
      case RENDERER_PROCESSES_NAME:
        return 'renderer processes';
      case GPU_PROCESS_NAME:
        return opt_requirePlural ? 'GPU processes' : 'the GPU process';
      case PPAPI_PROCESS_NAME:
        return opt_requirePlural ? 'PPAPI processes' : 'the PPAPI process';
      case ALL_PROCESSES_NAME:
        return 'all processes';
      case UNKNOWN_PROCESSES_NAME:
        return 'unknown processes';
      default:
        return '\'' + processName + '\' processes';
    }
  }

  /**
   * Function for adding entries with duplicate keys to a map without
   * overriding existing entries.
   *
   * This is achieved by appending numeric indices (2, 3, 4, ...) to duplicate
   * keys. Example:
   *
   *   var map = new Map();
   *   // map = Map {}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'a');
   *   // map = Map {"key" => "a"}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'b');
   *   // map = Map {"key" => "a", "key2" => "b"}.
   *                                ^^^^
   *   makeKeyUniqueAndSet(map, 'key', 'c');
   *   // map = Map {"key" => "a", "key2" => "b", "key3" => "c"}.
   *                                ^^^^           ^^^^
   */
  function makeKeyUniqueAndSet(map, key, value) {
    var uniqueKey = key;
    var nextIndex = 2;
    while (map.has(uniqueKey)) {
      uniqueKey = key + nextIndex;
      nextIndex++;
    }
    map.set(uniqueKey, value);
  }

  /**
   * Add general memory dump values calculated from all global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * PROCESS COUNTS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         process_count
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: count_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome[:{v8, malloc, ...}]:
   *         {effective_size, allocated_objects_size, locked_size}
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addGeneralMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps,
        gmd => true /* process all global memory dumps */,
        function(processDump, addProcessScalar) {
          // Increment memory:<browser-name>:<process-name>:process_count value.
          addProcessScalar({
            source: 'process_count',
            property: PROCESS_COUNT,
            value: 1
          });

          if (processDump.totals !== undefined) {
            tr.b.iterItems({
              'residentBytes': RESIDENT_SIZE,
              'peakResidentBytes': PEAK_RESIDENT_SIZE
            }, function(totalName, property) {
              addProcessScalar({
                source: 'reported_by_os',
                property: property,
                component: ['system_memory'],
                value: processDump.totals[totalName]
              });
            });
          }

          // Add memory:<browser-name>:<process-name>:reported_by_chrome:...
          // values.
          if (processDump.memoryAllocatorDumps === undefined)
            return;
          processDump.memoryAllocatorDumps.forEach(function(rootAllocatorDump) {
            CHROME_VALUE_PROPERTIES.forEach(function(property) {
              addProcessScalar({
                source: 'reported_by_chrome',
                component: [rootAllocatorDump.name],
                property: property,
                value: rootAllocatorDump.numerics[property.name]
              });
            });
            // Some dump providers add allocated objects size as
            // "allocated_objects" child dump.
            if (rootAllocatorDump.numerics['allocated_objects_size'] ===
                    undefined) {
              var allocatedObjectsDump =
                  rootAllocatorDump.getDescendantDumpByFullName(
                      'allocated_objects');
              if (allocatedObjectsDump !== undefined) {
                addProcessScalar({
                  source: 'reported_by_chrome',
                  component: [rootAllocatorDump.name],
                  property: ALLOCATED_OBJECTS_SIZE,
                  value: allocatedObjectsDump.numerics['size']
                });
              }
            }
          });

          // Add memory:<browser-name>:<process-name>:reported_by_chrome:v8:
          //     {heap, allocated_by_malloc}:...
          addV8MemoryDumpValues(processDump, addProcessScalar);
        },
        function(componentTree) {
          // Subtract memory:<browser-name>:<process-name>:reported_by_chrome:
          // tracing:<size-property> from memory:<browser-name>:<process-name>:
          // reported_by_chrome:<size-property> if applicable.
          var tracingNode = componentTree.children[1].get('tracing');
          if (tracingNode === undefined)
            return;
          for (var i = 0; i < componentTree.values.length; i++)
            componentTree.values[i].total -= tracingNode.values[i].total;
        }, values);
  }

  /**
   * Add memory dump values calculated from V8 components excluding
   * 'heap_spaces/other_spaces'.
   *
   * @param {!tr.model.ProcessMemoryDump} processDump The process memory dump.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8MemoryDumpValues(processDump, addProcessScalar) {
    var v8Dump = processDump.getMemoryAllocatorDumpByFullName('v8');
    if (v8Dump === undefined)
      return;
    v8Dump.children.forEach(function(isolateDump) {
      // v8:allocated_by_malloc:...
      var mallocDump = isolateDump.getDescendantDumpByFullName('malloc');
      if (mallocDump !== undefined) {
        addV8ComponentValues(mallocDump, ['v8', 'allocated_by_malloc'],
            addProcessScalar);
      }
      // v8:heap:...
      var heapDump = isolateDump.getDescendantDumpByFullName('heap_spaces');
      if (heapDump !== undefined) {
        addV8ComponentValues(heapDump, ['v8', 'heap'], addProcessScalar);
        heapDump.children.forEach(function(spaceDump) {
          if (spaceDump.name === 'other_spaces')
            return;
          addV8ComponentValues(spaceDump, ['v8', 'heap', spaceDump.name],
              addProcessScalar);
        });
      }
    });

    // V8 generates bytecode when interpreting and code objects when
    // compiling the javascript. Total code size includes the size
    // of code and bytecode objects.
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: CODE_AND_METADATA_SIZE,
      value: v8Dump.numerics['code_and_metadata_size']
    });
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: CODE_AND_METADATA_SIZE,
      value: v8Dump.numerics['bytecode_and_metadata_size']
    });
  }

  /**
   * Add memory dump values calculated from the specified V8 component.
   *
   * @param {!tr.model.MemoryAllocatorDump} v8Dump The V8 memory dump.
   * @param {!Array<string>} componentPath The component path for reporting.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8ComponentValues(componentDump, componentPath,
      addProcessScalar) {
    CHROME_VALUE_PROPERTIES.forEach(function(property) {
      addProcessScalar({
        source: 'reported_by_chrome',
        component: componentPath,
        property: property,
        value: componentDump.numerics[property.name]
      });
    });
  }

  var PROCESS_COUNT = {
    unit: count_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      if (componentPath.length > 0) {
        throw new Error('Unexpected process count non-empty component path: ' +
            componentPath.join(':'));
      }
      return 'total number of ' + convertProcessNameToUserFriendlyName(
          processName, true /* opt_requirePlural */);
    }
  };

  var EFFECTIVE_SIZE = {
    name: 'effective_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'effective size',
        componentPreposition: 'of'
      });
    }
  };

  var ALLOCATED_OBJECTS_SIZE = {
    name: 'allocated_objects_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'size of all objects allocated',
        totalUserFriendlyPropertyName: 'size of all allocated objects',
        componentPreposition: 'by'
      });
    }
  };

  var LOCKED_SIZE = {
    name: 'locked_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'locked (pinned) size',
        componentPreposition: 'of'
      });
    }
  };

  var PEAK_SIZE = {
    name: 'peak_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyName: 'peak size',
        componentPreposition: 'of'
      });
    }
  };

  var CODE_AND_METADATA_SIZE = {
    name: 'code_and_metadata_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildChromeValueDescriptionPrefix(componentPath, processName, {
        userFriendlyPropertyNamePrefix: 'size of',
        userFriendlyPropertyName: 'code and metadata'
      });
    }
  };

  var CHROME_VALUE_PROPERTIES = [
    EFFECTIVE_SIZE,
    ALLOCATED_OBJECTS_SIZE,
    LOCKED_SIZE,
    PEAK_SIZE
  ];

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_chrome:... value.
   *
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['malloc']).
   * @param {string} processName The canonical name of the process.
   * @param {{
   *     userFriendlyPropertyName: string,
   *     userFriendlyPropertyNamePrefix: (string|undefined),
   *     totalUserFriendlyPropertyName: (string|undefined),
   *     componentPreposition: (string|undefined) }}
   *     formatSpec Specification of how the property should be formatted.
   * @return {string} Prefix for the value's description (e.g.
   *     'effective size of malloc in the browser process').
   */
  function buildChromeValueDescriptionPrefix(
      componentPath, processName, formatSpec) {
    var nameParts = [];
    if (componentPath.length === 0) {
      nameParts.push('total');
      if (formatSpec.totalUserFriendlyPropertyName) {
        nameParts.push(formatSpec.totalUserFriendlyPropertyName);
      } else {
        if (formatSpec.userFriendlyPropertyNamePrefix)
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(formatSpec.userFriendlyPropertyName);
      }
      nameParts.push('reported by Chrome for');
    } else {
      if (formatSpec.componentPreposition === undefined) {
        // Use component name as an adjective
        // (e.g. 'size of V8 code and metadata').
        if (formatSpec.userFriendlyPropertyNamePrefix)
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(componentPath.join(':'));
        nameParts.push(formatSpec.userFriendlyPropertyName);
      } else {
        // Use component name as a noun with a preposition
        // (e.g. 'size of all objects allocated BY MALLOC').
        if (formatSpec.userFriendlyPropertyNamePrefix)
          nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(formatSpec.userFriendlyPropertyName);
        nameParts.push(formatSpec.componentPreposition);
        if (componentPath[componentPath.length - 1] === 'allocated_by_malloc') {
          nameParts.push('objects allocated by malloc for');
          nameParts.push(
              componentPath.slice(0, componentPath.length - 1).join(':'));
        } else {
          nameParts.push(componentPath.join(':'));
        }
      }
      nameParts.push('in');
    }
    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  var RESIDENT_SIZE = {
    name: 'resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'resident set size (RSS)');
    }
  };

  var PEAK_RESIDENT_SIZE = {
    name: 'peak_resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'peak resident set size');
    }
  };

  var PROPORTIONAL_RESIDENT_SIZE = {
    name: 'proportional_resident_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'proportional resident size (PSS)');
    }
  };

  var PRIVATE_DIRTY_SIZE = {
    name: 'private_dirty_size',
    unit: sizeInBytes_smallerIsBetter,
    buildDescriptionPrefix: function(componentPath, processName) {
      return buildOsValueDescriptionPrefix(componentPath, processName,
          'private dirty size');
    }
  };

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_os:... value.
   *
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['system', 'java_heap']).
   * @param {string} processName The canonical name of the process.
   * @param {string} userFriendlyPropertyName User-friendly name of the
   *     underlying property (e.g. 'private dirty size').
   * @return {string} Prefix for the value's description (e.g.
   *     'total private dirty size of the Java heal in the GPU process').
   */
  function buildOsValueDescriptionPrefix(
      componentPath, processName, userFriendlyPropertyName) {
    if (componentPath.length > 2) {
      throw new Error('OS value component path for \'' +
          userFriendlyPropertyName + '\' too long: ' + componentPath.join(':'));
    }

    var nameParts = [];
    if (componentPath.length < 2)
      nameParts.push('total');

    nameParts.push(userFriendlyPropertyName);

    if (componentPath.length > 0) {
      switch (componentPath[0]) {
        case 'system_memory':
          if (componentPath.length > 1) {
            var userFriendlyComponentName =
                SYSTEM_VALUE_COMPONENTS[componentPath[1]].userFriendlyName;
            if (userFriendlyComponentName === undefined) {
              throw new Error('System value sub-component for \'' +
                  userFriendlyPropertyName + '\' unknown: ' +
                  componentPath.join(':'));
            }
            nameParts.push('of', userFriendlyComponentName, 'in');
          } else {
            nameParts.push('of system memory (RAM) used by');
          }
          break;

        case 'gpu_memory':
          if (componentPath.length > 1) {
            nameParts.push('of the', componentPath[1]);
            nameParts.push('Android memtrack component in');
          } else {
            nameParts.push('of GPU memory (Android memtrack) used by');
          }
          break;

        default:
          throw new Error('OS value component for \'' +
              userFriendlyPropertyName + '\' unknown: ' +
              componentPath.join(':'));
      }
    } else {
      nameParts.push('reported by the OS for');
    }

    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  /**
   * Add heavy memory dump values calculated from heavy global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * MEMORY USAGE REPORTED BY THE OS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:system_memory:[{ashmem, native_heap, java_heap}:]
   *         {proportional_resident_size, private_dirty_size}
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:gpu_memory:[{gl, graphics, ...}:]
   *         proportional_resident_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome:v8:code_and_metadata_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addDetailedMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps,
        g => g.levelOfDetail === DETAILED,
        function(processDump, addProcessScalar) {
          // Add memory:<browser-name>:<process-name>:reported_by_os:
          // system_memory:... values.
          tr.b.iterItems(
              SYSTEM_VALUE_COMPONENTS,
              function(componentName, componentSpec) {
                tr.b.iterItems({
                  'proportionalResident': PROPORTIONAL_RESIDENT_SIZE,
                  'privateDirtyResident': PRIVATE_DIRTY_SIZE
                }, function(byteStatName, property) {
                  var node = getDescendantVmRegionClassificationNode(
                      processDump.vmRegions,
                      componentSpec.classificationPath);
                  var componentPath = ['system_memory'];
                  if (componentName)
                    componentPath.push(componentName);
                  addProcessScalar({
                    source: 'reported_by_os',
                    component: componentPath,
                    property: property,
                    value: node === undefined ?
                        0 : (node.byteStats[byteStatName] || 0)
                  });
                });
              });

          // Add memory:<browser-name>:<process-name>:reported_by_os:
          // gpu_memory:... values.
          var memtrackDump = processDump.getMemoryAllocatorDumpByFullName(
              'gpu/android_memtrack');
          if (memtrackDump !== undefined) {
            memtrackDump.children.forEach(function(memtrackChildDump) {
              addProcessScalar({
                source: 'reported_by_os',
                component: ['gpu_memory', memtrackChildDump.name],
                property: PROPORTIONAL_RESIDENT_SIZE,
                value: memtrackChildDump.numerics['memtrack_pss']
              });
            });
          }
        }, function(componentTree) {}, values);
  }

  // Specifications of components reported by the system.
  var SYSTEM_VALUE_COMPONENTS = {
    '': {
      classificationPath: [],
    },
    'java_heap': {
      classificationPath: ['Android', 'Java runtime', 'Spaces'],
      userFriendlyName: 'the Java heap'
    },
    'ashmem': {
      classificationPath: ['Android', 'Ashmem'],
      userFriendlyName: 'ashmem'
    },
    'native_heap': {
      classificationPath: ['Native heap'],
      userFriendlyName: 'the native heap'
    }
  };

  /**
   * Get the descendant of a VM region classification |node| specified by the
   * given |path| of child node titles. If |node| is undefined or such a
   * descendant does not exist, this function returns undefined.
   */
  function getDescendantVmRegionClassificationNode(node, path) {
    for (var i = 0; i < path.length; i++) {
      if (node === undefined)
        break;
      node = tr.b.findFirstInArray(node.children, c => c.title === path[i]);
    }
    return node;
  }

  /**
   * Add global memory dump counts to |values|. In particular, this function
   * adds the following values:
   *
   *   * DUMP COUNTS
   *     memory:{chrome, webview}:all_processes:dump_count
   *         [:{light, detailed, heap_profiler}]
   *     type: tr.v.Histogram
   *     unit: count_smallerIsBetter
   *
   * Note that unlike all other values generated by the memory metric, the
   * global memory dump counts are NOT instances of tr.v.Histogram
   * because it doesn't make sense to aggregate them (they are already counts
   * over all global dumps associated with the relevant browser).
   */
  function addMemoryDumpCountValues(browserNameToGlobalDumps, values) {
    browserNameToGlobalDumps.forEach(function(globalDumps, browserName) {
      var totalDumpCount = 0;
      var levelOfDetailNameToDumpCount = {};
      LEVEL_OF_DETAIL_NAMES.forEach(function(levelOfDetailName) {
        levelOfDetailNameToDumpCount[levelOfDetailName] = 0;
      });
      levelOfDetailNameToDumpCount[HEAP_PROFILER_DETAIL_NAME] = 0;

      globalDumps.forEach(function(globalDump) {
        totalDumpCount++;

        // Increment the level-of-detail-specific dump count (if possible).
        var levelOfDetailName =
            LEVEL_OF_DETAIL_NAMES.get(globalDump.levelOfDetail);
        if (levelOfDetailName === undefined)
          return;  // Unknown level of detail.
        levelOfDetailNameToDumpCount[levelOfDetailName]++;
        if (globalDump.levelOfDetail === DETAILED) {
          if (detectHeapProfilerInMemoryDump(globalDump)) {
            levelOfDetailNameToDumpCount[HEAP_PROFILER_DETAIL_NAME]++;
          }
        }
      });

      // Add memory:<browser-name>:all_processes:dump_count[:<level>] values.
      reportMemoryDumpCountAsValue(browserName, undefined /* total */,
          totalDumpCount, values);
      tr.b.iterItems(levelOfDetailNameToDumpCount,
          function(levelOfDetailName, levelOfDetailDumpCount) {
            reportMemoryDumpCountAsValue(browserName, levelOfDetailName,
                levelOfDetailDumpCount, values);
          });
    });
  }

  /**
   * Check whether detailed global dump has heap profiler information or not.
   */
  function detectHeapProfilerInMemoryDump(globalDump) {
    var detected = false;
    tr.b.iterItems(globalDump.processMemoryDumps, function(_, processDump) {
      if (detected) return;
      if (processDump.heapDumps && processDump.heapDumps.malloc) {
        var mallocDump = processDump.heapDumps.malloc;
        if (mallocDump.entries && mallocDump.entries.length > 0) {
          detected = true;
        }
      }
    });
    return detected;
  }

  /**
   * Add a tr.v.Histogram value to |values| reporting that the number of
   * |levelOfDetailName| memory dumps added by |browserName| was
   * |levelOfDetailCount|.
   */
  function reportMemoryDumpCountAsValue(
      browserName, levelOfDetailName, levelOfDetailDumpCount, values) {
    // Construct the name of the memory value.
    var nameParts = ['memory', browserName, 'all_processes', 'dump_count'];
    if (levelOfDetailName !== undefined)
      nameParts.push(levelOfDetailName);
    var name = nameParts.join(':');

    // Build the underlying histogram for the memory value.
    var histogram = new tr.v.Histogram(name, count_smallerIsBetter,
        BOUNDARIES_FOR_UNIT_MAP.get(count_smallerIsBetter));
    histogram.addSample(levelOfDetailDumpCount);

    // If |levelOfDetail| argument is undefined it means a total value.
    var userFriendlyLevelOfDetail =
        (levelOfDetailName || 'all').replace('_', ' ');

    // Build the options for the memory value.
    histogram.description = [
      'total number of',
      userFriendlyLevelOfDetail,
      'memory dumps added by',
      convertBrowserNameToUserFriendlyName(browserName),
      'to the trace'
    ].join(' ');

    // Report the memory value.
    values.addHistogram(histogram);
  }

  /**
   * Add generic values extracted from process memory dumps and aggregated by
   * process name and component path into |values|.
   *
   * For each browser and set of global dumps in |browserNameToGlobalDumps|,
   * |customProcessDumpValueExtractor| is applied to every process memory dump
   * associated with the global memory dump. The second argument provided to the
   * callback is a function for adding extracted values:
   *
   *   function sampleProcessDumpCallback(processDump, addProcessValue) {
   *     ...
   *     addProcessScalar({
   *       source: 'reported_by_chrome',
   *       component: ['system', 'native_heap'],
   *       property: 'proportional_resident_size',
   *       value: pssExtractedFromProcessDump2,
   *       descriptionPrefixBuilder: function(componentPath) {
   *         return 'PSS of ' + componentPath.join('/') + ' in';
   *       }
   *     });
   *     ...
   *   }
   *
   * For each global memory dump, the extracted values are summed by process
   * name (browser_process, renderer_processes, ..., all_processes) and
   * component path (e.g. gpu is a sum of gpu:gl, gpu:graphics, ...). The sums
   * are then aggregated over all global memory dumps associated with the given
   * browser. For example, assuming that |customProcessDumpValueExtractor|
   * extracts 'proportional_resident_size' values for component paths
   * ['X', 'A'], ['X', 'B'] and ['Y'] under the same 'source' from each process
   * memory dump, the following values will be reported (for Chrome):
   *
   *    memory:chrome:browser_process:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    ...
   *
   *    memory:chrome:all_processes:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all process dumps in global dump 1,
   *          ...
   *          sum of X:A in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all process dumps in global dump 1,
   *          ...
   *          sum of Y in all process dumps in global dump N
   *    ]
   *
   *    memory:chrome:all_processes:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all process dumps in global dump N
   *        ]
   *
   * where global dumps 1 to N are the global dumps associated with the given
   * browser.
   *
   * @param {!Map<string, !Array<!tr.model.GlobalMemoryDump>}
   *     browserNameToGlobalDumps Map from browser names to arrays of global
   *     memory dumps. The generic values will be extracted from the associated
   *     process memory dumps.
   * @param {!function(!tr.model.GlobalMemoryDump): boolean}
   *     customGlobalDumpFilter Predicate for filtering global memory dumps.
   * @param {!function(
   *     !tr.model.ProcessMemoryDump,
   *     !function(!{
   *         source: string,
   *         componentPath: (!Array<string>|undefined),
   *         property: !{name: string, unit: !tr.b.Unit, buildDescriptionPrefix:
   *                     !function(!Array<string>, string): string},
   *         value: (!tr.v.Histogram|number|undefined)
   *     }))}
   *     customProcessDumpValueExtractor Callback for extracting values from a
   *     process memory dump.
   * @param {!function(!tr.b.MultiDimensionalViewNode)}
   *     customComponentTreeModifier Callback applied to every component tree
   *     wrt each process name.
   * @param {!tr.v.HistogramSet} values List of values to which the
   *     resulting aggregated values are added.
   */
  function addMemoryDumpValues(browserNameToGlobalDumps, customGlobalDumpFilter,
      customProcessDumpValueExtractor, customComponentTreeModifier,
      values) {
    browserNameToGlobalDumps.forEach(function(globalDumps, browserName) {
      var filteredGlobalDumps = globalDumps.filter(customGlobalDumpFilter);
      var sourceToPropertyToBuilder = extractDataFromGlobalDumps(
          filteredGlobalDumps, customProcessDumpValueExtractor);
      reportDataAsValues(sourceToPropertyToBuilder, browserName,
          customComponentTreeModifier, values);
    });
  }

  /**
   * For each global memory dump in |globalDumps|, calculate per-process-name
   * sums of values extracted by |customProcessDumpValueExtractor| from the
   * associated process memory dumps.
   *
   * This function returns the following nested map structure:
   *
   *  Source name (Map key, e.g. 'reported_by_os')
   *    -> Property (Map key, e.g. PROPORTIONAL_RESIDENT_SIZE)
   *      -> processAndComponentTreeBuilder
   *
   *  where |processAndComponentTreeBuilder| is a
   *  tr.b.MultiDimensionalViewBuilder:
   *
   *  Process name (0th dimension key, e.g. 'browser_process') x
   *  Component path (1st dimension keys, e.g. ['system', 'native_heap'])
   *    -> Sum of value over the processes (number).
   *
   * See addMemoryDumpValues for more details.
   */
  function extractDataFromGlobalDumps(
      globalDumps, customProcessDumpValueExtractor) {
    var sourceToPropertyToBuilder = new Map();
    var dumpCount = globalDumps.length;
    globalDumps.forEach(function(globalDump, dumpIndex) {
      tr.b.iterItems(globalDump.processMemoryDumps, function(_, processDump) {
        extractDataFromProcessDump(
            processDump, sourceToPropertyToBuilder, dumpIndex, dumpCount,
            customProcessDumpValueExtractor);
      });
    });
    return sourceToPropertyToBuilder;
  }

  function extractDataFromProcessDump(processDump, sourceToPropertyToBuilder,
      dumpIndex, dumpCount, customProcessDumpValueExtractor) {
    // Process name is typically 'browser', 'renderer', etc.
    var rawProcessName = processDump.process.name;
    var processNamePath = [canonicalizeProcessName(rawProcessName)];

    customProcessDumpValueExtractor(
        processDump,
        function addProcessScalar(spec) {
          if (spec.value === undefined)
            return;

          var component = spec.component || [];
          function createDetailsForErrorMessage() {
            return ['source=', spec.source, ', property=',
              spec.property.name || '(undefined)', ', component=',
              component.length === 0 ? '(empty)' : component.join(':'),
              ' in ', processDump.process.userFriendlyName].join('');
          }

          var value;
          if (spec.value instanceof tr.b.Scalar) {
            value = spec.value.value;
            if (spec.value.unit !== spec.property.unit) {
              throw new Error('Scalar unit for ' +
                  createDetailsForErrorMessage() + ' (' +
                  spec.value.unit.unitName +
                  ') doesn\'t match the unit of the property (' +
                  spec.property.unit.unitName + ')');
            }
          } else {
            value = spec.value;
          }

          var propertyToBuilder = sourceToPropertyToBuilder.get(spec.source);
          if (propertyToBuilder === undefined) {
            propertyToBuilder = new Map();
            sourceToPropertyToBuilder.set(spec.source, propertyToBuilder);
          }

          var builder = propertyToBuilder.get(spec.property);
          if (builder === undefined) {
            builder = new tr.b.MultiDimensionalViewBuilder(
                2 /* dimensions (process name and component path) */,
                dumpCount /* valueCount */),
            propertyToBuilder.set(spec.property, builder);
          }

          var values = new Array(dumpCount);
          values[dumpIndex] = value;

          builder.addPath(
              [processNamePath, component] /* path */, values,
              tr.b.MultiDimensionalViewBuilder.ValueKind.TOTAL /* valueKind */);
        });
  }

  function reportDataAsValues(sourceToPropertyToBuilder, browserName,
      customComponentTreeModifier, values) {
    // For each source name (e.g. 'reported_by_os')...
    sourceToPropertyToBuilder.forEach(function(propertyToBuilder, sourceName) {
      // For each property (e.g. EFFECTIVE_SIZE)...
      propertyToBuilder.forEach(function(builders, property) {
        var tree = builders.buildTopDownTreeView();
        reportComponentDataAsValues(browserName, sourceName, property,
            [] /* componentPath */, tree, values, customComponentTreeModifier);
      });
    });
  }

  /**
   * For the given |browserName| (e.g. 'chrome'), |property|
   * (e.g. EFFECTIVE_SIZE), |componentPath| (e.g. ['v8']), add
   * a tr.v.Histogram with |unit| aggregating the total
   * values of the associated |componentNode| across all timestamps
   * (corresponding to global memory dumps associated with the given browser)
   * |values| for each process (e.g. 'gpu_process', 'browser_process', etc).
   * We also report a special 'all_processes' histogram which agregates all
   * others, this has a RelatedHistogramBreakdown diagnostic explaining
   * how it is built from the other histograms.
   *
   * See addMemoryDumpValues for more details.
   */
  function reportComponentDataAsValues(browserName, sourceName, property,
      componentPath, tree, values, customComponentTreeModifier) {
    var breakdown = new tr.v.d.RelatedHistogramBreakdown();
    breakdown.colorScheme = PROCESS_COLOR_SCHEME_NAME;

    // For each process report the value for this component.
    tree.children[0].forEach(function(processTree, processName) {
      customComponentTreeModifier(processTree);
      var numeric = buildNamedMemoryNumericFromNode(browserName,
          sourceName, property, processName, componentPath, processTree);
      // Report the memory value.
      values.addHistogram(numeric);
      // Add it to the breakdown.
      breakdown.set(processName, numeric);
    });

    // Report the total over 'all' processes.
    customComponentTreeModifier(tree);
    var numeric = buildNamedMemoryNumericFromNode(browserName, sourceName,
        property, 'all_processes', componentPath, tree);
    numeric.diagnostics.set('processes', breakdown);
    values.addHistogram(numeric);

    // Recursively report memory values for sub-components.
    var depth = componentPath.length;
    componentPath.push(undefined);
    tree.children[1].forEach(function(childNode, childName) {
      componentPath[depth] = childName;
      reportComponentDataAsValues(
          browserName, sourceName, property, componentPath,
          childNode, values, customComponentTreeModifier);
    });
    componentPath.pop();
  }

  /**
   * Gets the name for a histogram.
   * The histograms have the following naming scheme:
   * memory:chrome:browser_process:reported_by_chrome:v8:heap:effective_size_avg
   *        ^browser ^process      ^source            ^component  ^property
   */
  function getNumericName(
      browserName, sourceName, propertyName, processName, componentPath) {
    // Construct the name of the memory value.
    var nameParts = ['memory', browserName, processName, sourceName].concat(
        componentPath);
    if (propertyName !== undefined) nameParts.push(propertyName);
    return nameParts.join(':');
  }

  /**
   * Gets the description of a histogram.
   */
  function getNumericDescription(
      property, browserName, processName, componentPath) {
    return [
      property.buildDescriptionPrefix(componentPath, processName),
      'in',
      convertBrowserNameToUserFriendlyName(browserName)
    ].join(' ');
  }

  /**
   * Create a memory tr.v.Histogram with |unit| and add all total values in
   * |node| to it. Names and describes the histogram according to the
   * |browserName|, |sourceName|, |property|, |processName| and
   * |componentPath|.
   */
  function buildNamedMemoryNumericFromNode(
      browserName, sourceName, property, processName, componentPath, node) {
    var name = getNumericName(
        browserName, sourceName, property.name, processName, componentPath);
    var description = getNumericDescription(
        property, browserName, processName, componentPath);

    // Build the underlying numeric for the memory value.
    var numeric = buildMemoryNumericFromNode(name, node, property.unit);
    numeric.description = description;
    return numeric;
  }

  /**
   * Create a memory tr.v.Histogram with |unit| and add all total values in
   * |node| to it.
   */
  function buildMemoryNumericFromNode(name, node, unit) {
    var histogram = new tr.v.Histogram(
        name, unit, BOUNDARIES_FOR_UNIT_MAP.get(unit));
    node.values.forEach(v => histogram.addSample(v.total));
    return histogram;
  }

  tr.metrics.MetricRegistry.register(memoryMetric, {
    supportsRangeOfInterest: true
  });

  return {
    memoryMetric,
  };
});
</script>
