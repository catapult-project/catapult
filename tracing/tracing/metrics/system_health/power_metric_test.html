<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/core/test_utils.html">
<link rel="import" href="/tracing/importer/find_input_expectations.html">
<link rel="import" href="/tracing/metrics/system_health/power_metric.html">
<link rel="import" href="/tracing/model/user_model/idle_expectation.html">
<link rel="import" href="/tracing/model/user_model/load_expectation.html">
<link rel="import" href="/tracing/value/histogram_set.html">

<script>
'use strict';

function containsData(values, name) {
  for (var value of values)
    if (value.name === name)
      return (value.running !== undefined);

  return undefined;
}

function getMetricValueCount(values, name) {
  for (var value of values)
    if (value.name === name && value.running !== undefined)
      return value.running.count;

  return undefined;
}

function getMetricValueSum(values, name) {
  for (var value of values)
    if (value.name === name && value.running !== undefined)
      return value.running.sum;

  return undefined;
}

function getMetricValueMin(values, name) {
  for (var value of values)
    if (value.name === name && value.running !== undefined)
      return value.running.min;

  return undefined;
}

function getMetricValueAvg(values, name) {
  for (var value of values)
    if (value.name === name && value.running !== undefined)
      return value.running.mean;

  return undefined;
}

function getMetricValueMax(values, name) {
  for (var value of values)
    if (value.name === name && value.running !== undefined)
      return value.running.max;

  return undefined;
}

tr.b.unittest.testSuite(function() {
  test('powerMetric_computesChromeBoundsCorrectly', function() {
    // Tests if Chrome bounds are computed correctly when there
    // are both browser and renderer threads in the trace.
    var model = tr.c.TestUtils.newModel((model) => {
      var rendererProcess = model.getOrCreateProcess(1234);
      var rendererThread = rendererProcess.getOrCreateThread(1);
      rendererThread.name = 'CrRendererMain';
      var browserProcess = model.getOrCreateProcess(5678);
      var browserThread = browserProcess.getOrCreateThread(2);
      browserThread.name = 'CrBrowserMain';
      rendererThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 200.0,
        duration: 500.0,
        args: {frame: '0xdeadbeef'}
      }));
      browserThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000.0,
        duration: 500.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 2000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 0, 2000));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueMin(valueSet, 'idle:power'), 200.0, .01);
    assert.closeTo(getMetricValueAvg(valueSet, 'idle:power'), 849.5, .01);
    assert.closeTo(getMetricValueMax(valueSet, 'idle:power'), 1499.0, .01);
  });

  test('powerMetric_noPowerSeries', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.lengthOf(valueSet, 0);
  });

  test('powerMetric_emptyPowerSeries', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.lengthOf(valueSet, 0);
  });

  test('powerMetric_noChromeTrace', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    // Only the whole trace power metric should contain data.
    assert(containsData(valueSet, 'story:power'));
    assert(!containsData(valueSet, 'load:energy'));
    assert(!containsData(valueSet, 'after_load:power'));
  });

  test('powerMetric_emptyChromeTrace', function() {
    var valueSet = new tr.v.HistogramSet();
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.LoadExpectation(
          model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 500));
    });
    tr.metrics.sh.powerMetric(valueSet, model);

    assert(containsData(valueSet, 'story:power'));
    assert(!containsData(valueSet, 'load:energy'));
    assert(!containsData(valueSet, 'after_load:power'));
  });

  test('powerMetric_powerSeriesStartsLate', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 300; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.LoadExpectation(
          model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert(containsData(valueSet, 'story:power'));
    assert(!containsData(valueSet, 'load:energy'));
    assert(!containsData(valueSet, 'after_load:power'));
  });

  test('powerMetric_powerSeriesEndsEarly', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 700; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.LoadExpectation(
          model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert(containsData(valueSet, 'story:power'));
    assert(!containsData(valueSet, 'load:energy'));
    assert(!containsData(valueSet, 'after_load:power'));
  });

  test('powerMetric_generic_oneStageEachType_irBeyondChrome', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.ResponseExpectation(
          model, tr.importer.INITIATOR_TYPE.SCROLL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 1500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueSum(valueSet,
        'scroll_response:energy'), 125, 0.5);
    assert.closeTo(getMetricValueAvg(valueSet,
        'idle:power'), 750, 0.5);
    assert.closeTo(getMetricValueAvg(valueSet,
        'story:power'), 500, 0.5);
  });

  test('powerMetric_story_minAvgMax', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.ResponseExpectation(
          model, tr.importer.INITIATOR_TYPE.SCROLL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 1500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueMin(valueSet, 'story:power'), 0, .01);
    assert.closeTo(getMetricValueAvg(valueSet, 'story:power'), 500, .01);
    assert.closeTo(getMetricValueMax(valueSet, 'story:power'), 1000, .01);
  });

  test('powerMetric_generic_oneUEBeforeChrome', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 500,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 0, 300));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 300, 1000));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueAvg(valueSet,
        'idle:power'), 750, 0.5);
  });

  test('powerMetric_generic_multipleStagesEachType', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.ResponseExpectation(
            model, tr.importer.INITIATOR_TYPE.SCROLL, 0, 200));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
            model, 200, 300));
      model.userModel.expectations.push(new tr.model.um.ResponseExpectation(
            model, tr.importer.INITIATOR_TYPE.SCROLL, 500, 400));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
            model, 900, 100));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueSum(valueSet,
        'scroll_response:energy'), 300, 0.6);
    assert.closeTo(getMetricValueAvg(valueSet,
        'idle:power'), 500, 0.6);
    assert.equal(getMetricValueCount(valueSet,
        'scroll_response:energy'), 2);
    assert.equal(getMetricValueCount(valueSet,
        'idle:power'), 400);
  });

  test('powerMetric_loading_oneInterval_samplesBeyondChrome', function() {
    // Interval of load is [200, 15400].
    // Trace goes until 22150.
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1984);
      var mainThread = rendererProcess.getOrCreateThread(2);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 200,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      rendererProcess.objects.addSnapshot('ptr', 'loading', 'FrameLoader', 300,
          {isLoadingMainFrame: true, frame: {id_ref: '0xdeadbeef'},
            documentLoaderURL: 'http://example.com'});

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'loading',
        title: 'firstMeaningfulPaintCandidate',
        start: 9180,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'loading',
        title: 'firstMeaningfulPaintCandidate',
        start: 9200,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 9350,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 11150,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 12550,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 14950,
        duration: 500,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 22150,
        duration: 10,
      }));

      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 15400; i++)
        model.device.powerSeries.addPowerSample(i, 20);
      for (var i = 15401; i <= 22160; i++)
        model.device.powerSeries.addPowerSample(i, 10);
      for (var i = 22160; i <= 30000; i++)
        model.device.powerSeries.addPowerSample(i, 10);
    });

    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);
  // Energy for first load is 20 W * 15.2 s
  // (interval from 0.2 s to 15.4 s)
    assert.closeTo(
        getMetricValueAvg(valueSet, 'load:energy'), 304, 0.1);
    assert.closeTo(
        getMetricValueAvg(valueSet, 'after_load:power'), 10, 0.01);
  });

  test('powerMetric_loading_noMeaningfulPaint', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1984);
      var mainThread = rendererProcess.getOrCreateThread(2);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 200,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      rendererProcess.objects.addSnapshot('ptr', 'loading', 'FrameLoader', 300,
          {isLoadingMainFrame: true, frame: {id_ref: '0xdeadbeef'},
            documentLoaderURL: 'http://example.com'});

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 9350,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 11150,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 12550,
        duration: 100,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 14950,
        duration: 500,
      }));

      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'toplevel',
        title: 'TaskQueueManager::ProcessTaskFromWorkQueue',
        start: 22150,
        duration: 10,
      }));

      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 15400; i++)
        model.device.powerSeries.addPowerSample(i, 20);
      for (var i = 15401; i <= 22160; i++)
        model.device.powerSeries.addPowerSample(i, 10);
    });

    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);
    // Energy for first load is 20 W * 15.2 s
    // (interval from 0.2 s to 15.4 s)
    assert.equal(getMetricValueCount(valueSet, 'after_load:power'), undefined);
  });

  test('powerMetric_scroll_oneStageEachType', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.SCROLL, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueAvg(valueSet,
        'scroll_animation:power'), 250, 0.5);
  });

  test('powerMetric_scroll_multipleStagesEachType', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.SCROLL, 0, 200));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 200, 300));
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.SCROLL, 500, 200));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 700, 300));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueAvg(valueSet,
        'scroll_animation:power'), 350, 0.6);
  });

  test('powerMetric_video_oneStageEachType', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.VIDEO, 0, 500));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 500, 500));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueAvg(valueSet, 'video_animation:power'),
        250, 0.5);
  });

  test('powerMetric_video_multipleStagesEachType', function() {
    var model = tr.c.TestUtils.newModel(function(model) {
      var rendererProcess = model.getOrCreateProcess(1234);
      var mainThread = rendererProcess.getOrCreateThread(1);
      mainThread.name = 'CrRendererMain';
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 0,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      mainThread.sliceGroup.pushSlice(tr.c.TestUtils.newSliceEx({
        cat: 'blink.user_timing',
        title: 'navigationStart',
        start: 1000,
        duration: 0.0,
        args: {frame: '0xdeadbeef'}
      }));
      model.device.powerSeries = new tr.model.PowerSeries(model.device);
      for (var i = 0; i <= 1000; i++)
        model.device.powerSeries.addPowerSample(i, i);
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.VIDEO, 0, 200));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 200, 300));
      model.userModel.expectations.push(new tr.model.um.AnimationExpectation(
          model, tr.importer.INITIATOR_TYPE.VIDEO, 500, 200));
      model.userModel.expectations.push(new tr.model.um.IdleExpectation(
          model, 700, 300));
    });
    var valueSet = new tr.v.HistogramSet();
    tr.metrics.sh.powerMetric(valueSet, model);

    assert.closeTo(getMetricValueAvg(valueSet, 'video_animation:power'),
        350, 0.6);
  });
});
</script>
